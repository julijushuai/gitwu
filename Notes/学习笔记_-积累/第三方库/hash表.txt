Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2022-06-17T18:21:55+08:00

====== hash表 ======
Created 星期五 17 六月 2022


hash函数就是根据key计算出应该存储地址的位置，而哈希表是基于哈希函数建立的一种查找表.



**hash函数的构造方法**
	1、直接定制法：
		以关键字的线性函数：H(key) = a*key +b
		优缺点：简单、均匀。  限制大，仅限于地址大小 = 关键字集合的情况
	
	2、数字分析法：
		假设关键字集合中的每个关键字key都是由s位数字组成（k 1 , k 2 , … … , k n    k_1,k_2,……,k_nk ），
		分析key中的全体数据，并从中提取分布均匀的若干位或他们的组合构成全体
		优缺点：通常用于数字位数较长的情况，必须数字存在一定规律，其必须知道数字的分布情况。
		
	3、平方取中法：
		关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，__通过平方扩大差异，__
		而后取中间数位作为最终存储地址。
		
		这种方法适合事先不知道数据并且数据长度较小的情况。
	
	4、折叠法：
		如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为hash地址。
		该方法适用于数字位数较多且事先不知道数据分布的情况
		
	5、除留余数法--用的较多
		H（key）= key MOD p（p <= m  m为麦长）
		很明显，如何选取p是个关键问题
**hash函数设计的考虑因素**
	1.计算散列地址所需要的时间（即hash函数本身不要太复杂）
	2.关键字的长度
	3.表长
	4.关键字分布是否均匀，是否有规律可循
	5.设计的hash函数在满足以上条件的情况下尽量减少冲突

**hash冲突**
	即不同的key值计算出相同的地址。
	
**hash冲突的解决方案**
	1、开放定制法
		 keyi储存位置{{.\pasted_image.png}}   m为表长。
		di的三种取法：
			1）线性探测在散列
			di = c * i 
			2）平方探测再散列
			di = 1^2, -1^2, 2^2,-2^2,.......
			平方探测时表长m必须为4j+3的质数（平方探测表长有限制）
			3）随机探测在散列（双探测在散列）
			di是一组伪随机数列
			随机探测时m和di没有公因子（随机探测di有限制）

	2、链地址法
	产生hash冲突后在存储数据后面加一个指针，指向后面冲突的数据
	
	3、公共溢出区法
	
**hash表的查找**
	查找过程和造表过程一致，假设采用开放定址法处理冲突，则查找过程为：
	对于给定的key，计算hash地址index = H（key）
	如果数组arr【index】的值为空 则查找不成功
	如果数组arr【index】== key 则查找成功
	__否则 使用冲突解决方法求下一个地址__，直到arr【index】== key或者 arr【index】==null

	影响hash表的查找效率：
	1）选用的hash函数
	2）选用的处理冲突的方式
	3）hash表的饱和度，装载因子 α=n/m(n表示实际装载数据长度 m为表长)
	
**hash表的删除**
	1、链地址法是可以直接删除元素的
	2、开放地址不能直接删除，所以应该是删除后并置入一个原来不存在的数据，如-1；
	
**第三方hash库的使用：https://www.cnblogs.com/dongxb/p/14212531.html**

	1、查找：HASH_ADD_INT( users, id, s );
		第一个参数users是哈希表，第二个参数是user_id的地址（一定要传递地址）。最后s是输出变量。当可以在哈希表中找到相应键值时，s返回给定键的结构，当找不到时s返回NULL。
	2、替换：HASH_REPLACE（*head, id, newNode, oldNode）
		HASH_REPLACE宏等效于HASH_ADD宏，HASH_REPLACE会尝试查找和删除项目外。如果找到并删除了一个项目，它还将返回该项目的指针作为输出参数。
	3、删除：HASH_DEL(users, user)
		这里users是哈希表，user是指向我们要从哈希中删除的结构的指针。
		要从哈希表中删除结构，必须具有指向它的指针。（如果只有键值，请先执行HASH_FIND以获取结构指针）。
		删除结构只是将其从哈希表中删除，并非free 。何时释放结构的选择完全取决于程序员自己；uthash永远不会释放您的结构。
	4、循环删除：	HASH_ITER
		是一个宏定义，程序执行时被替换为一个循环。
	5、删除hash表的使用元素：HASH_CLEAR(hh,users)
		值删除所以项目，但不释放他们或者进行清理每个元素，之后列表头（此处为users）将设置为NULL。
	6、计算hash表元素的个数：HASH_COUNT(users)；
		当users为NULL时，HASH_COUNT会返回0。
	7、如何遍历hash表中的所以项目
		通过hh.prev和hh.next指针，分别可以向前和向后迭代。可以通过重复跟随这些指针来访问哈希中的所有项目，因此哈希也是双链表。
	8、排序hash表：HASH_SORT( users, name_sort );
		第二个参数是指向比较函数的指针。它必须接受两个指针参数（要比较的项目），并且如果第一个项目分别在第二个项目之前，等于或之后排序，则必须返回小于零，零或大于零的int。 （这与标准C库中的strcmp或qsort使用的约定相同）。
	9、键值的各种类型举例：
		1）整形键值：
			a. 当键值为整型时，可以使用HASH_ADD_INT和HASH_FIND_INT。（对于所有类型的键，其他操作（例如HASH_DELETE和）HASH_SORT都是相同的）。
		2）字符串键值：
			当键值为字符串时，具体要使用那个函数取决于结构体中的键值为字符串数组还是字符串指针。 这一点很重要。当结构体中的键值为字符串数组时，使用HASH_ADD_STR。键值为字符串指针时使用HASH_ADD_KEYPTR。
			[[https://www.cnblogs.com/dongxb/p/14212531.html|看栗子]]
		3）结构体键值

