Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2022-06-07T11:13:27+08:00

====== 3、Makefile的工作流程 ======
Created 星期二 07 六月 2022

**Makefile文件的命名：**
	我们编写 Makefile 的时可以使用的文件的名称 "GNUmakefile" 、"makefile" 、"Makefile" ，make 执行时回去寻找 Makefile 文件，找文件的顺序也是这样的。
	推荐使用Makefile（一般在工程中这么写，大写的会比较规范），文件不在会报错。

	它的具体工作顺序是：当在 shell 提示符下输入 make 命令以后。 make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。在我们的例子中，第一个规则就是目标 "main" 所在的规则。规则描述了 "main" 的依赖关系，并定义了链接 ".o" 文件生成目标 "main" 的命令；make 在执行这个规则所定义的命令之前，首先处理目标 "main" 的所有的依赖文件（例子中的那些 ".o" 文件）的更新规则（以这些 ".o" 文件为目标的规则）

对这些 ".o" 文件为目标的规则处理有下列三种情况：
	目标 ".o" 文件不存在，使用其描述规则创建它；
	目标 ".o" 文件存在，目标 ".o" 文件所依赖的 ".c" 源文件 ".h" 文件中的任何一个比目标 ".o" 文件“更新”（在上一次 make 之后被修改）。则根据规则重新编译生成它；
	目标 ".o" 文件存在，目标 ".o" 文件比它的任何一个依赖文件（".c" 源文件、".h" 文件）“更新”（它的依赖文件在上一次 make 之后没有被修改），则什么也不做。

**清楚工作目录中的过程文件**
	在编写Makefile文件的时候会在末尾加上这样的规则语句：
		.PHONY : clean
		clean : 
			rm -rf *.o test
	说明：
		其中 "*.o" 是执行过程中产生的中间文件，"test" 是最终生成的执行文件。我们可以看到 clean 是独立的，它只是一个伪目标（在《Makefile伪目标》的章节中详细介绍），不是具体的文件。不会与第一个目标文件相关联，所以我们在执行 make 的时候也不会执行下面的命令。在shell 中执行 "__make clean__**"** 命令，编译时的中间文件和生成的最终目标文件都会被清除，方便我们下次的使用。

